2+2
obj1<-2+2
obj2<-obj1*2
getwd()
install.packages("installr")
require(installr)
updateR()
install.packages(tidyverse)
install.packages("tidyverse")
ggplot2::mpg
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy))
library(ggplot2)
ggplot2::mpg
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy))
ggplot(data=mpg)
nrow(mpg)
ncol(mpg)
ggplot(data=mpg) +
geom_point(mapping=aes(x=cyl, y=hwy))
ggplot(data=mpg) +
geom_point(mapping=aes(x=class, y=drv))
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy, color=class))
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy, alpha=class))
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy, shape=class))
ggplot(data=mpg) +
geom_point(mapping=aes(x=displ, y=hwy, shape=class, color=class))
list.of.packages <- c("igraph","fabricatr", "keyplayer", "rmarkdown", "knitr", "RColorBrewer","sna","MASS","naturalsort", "pander") # List packages used for the analysis
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])] # new packages that were not already installed
# Install new packages
if(length(new.packages)){install.packages(new.packages)}
# Load all packages for analysis
lapply(list.of.packages, require, character.only = TRUE)
rm(list=ls())
vertex_datapath <- "vertex_df.csv" # vertex (ego) dataframe with attributes
edge_datapath <- "edge_df.csv" # edge-related data/attributes between individuals
list.of.packages <- c("igraph","fabricatr", "keyplayer", "rmarkdown", "knitr", "RColorBrewer","sna","MASS","naturalsort", "pander") # List packages used for the analysis
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])] # new packages that were not already installed
# Install new packages
if(length(new.packages)){install.packages(new.packages)}
# Load all packages for analysis
lapply(list.of.packages, require, character.only = TRUE)
basedirectory <- "C:/Users/solit/Documents/GitHub/Sicklefin-Redhorse-Analysis"
setwd(basedirectory)
list.of.packages <- c("stringr", "reshape2", "RMark","lubridate", "tidyverse", "rjags", "coda")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
lapply(list.of.packages, require, character.only = TRUE)
load("SRH_JS_phiSex_pGearEffort_100000.gzip")
out.jc1<-summary(sr.ms.js.jc1) # model output
jc1.stats<-out.jc1$statistics # parameter estimates
jc1.quants<-out.jc1$quantiles # 95% confidence intervals
pop.size<-data.frame(cbind(Year=c(2014:2018),pop.est=jc1.stats[6:10, 1], lower=jc1.quants[6:10, 1], upper=jc1.quants[6:10, 5]))
pop.size.plot<-ggplot(pop.size, aes(Year, y=pop.est, ymin=lower, ymax=upper))
pop.size.plot+geom_pointrange(size=1) + labs(y="Population Size")+theme(axis.text=element_text(size=20), axis.title=element_text(size=20, face="bold"))+ylim(0,3100)
recruits<-data.frame(cbind(Year=c(2015:2018),pop.est=jc1.stats[2:5, 1], lower=jc1.quants[2:5, 1], upper=jc1.quants[2:5, 5]))
recruits.plot<-ggplot(recruits, aes(Year, y=pop.est, ymin=lower, ymax=upper))
recruits.plot+geom_pointrange(size=1) + labs(y="Number of Recruits")+theme(axis.text=element_text(size=20), axis.title=element_text(size=20, face="bold"))+ylim(0,1000)
jc1.stats
jc1.quants
jc1.stats
raw.dat<-read.csv("Sicklefin_Capture_Data.csv")
raw.dat<-raw.dat[raw.dat$Sex!="Unknown",] # remove rows where Sex is "Unknown"
raw.dat$CollectDate<-strptime(raw.dat$CollectDate, format="%d-%b-%y") # convert date format
raw.dat$CollectYear.1<-ifelse(is.na(raw.dat$CollectDate), raw.dat$CollectYear, year(raw.dat$CollectDate))
# Tag type
raw.dat$Tag_Type<-ifelse(raw.dat$PIT_Type=="FDX-B",0,1)
tag.dat<-data.frame(with(raw.dat, table(raw.dat$Individual_ID, raw.dat$Tag_Type, raw.dat$CollectYear.1)))
tag.dat<-tag.dat[tag.dat$Freq>0,]
tag.dat<-spread(tag.dat, Var3, Var2)
coalesce_by_column <- function(df) {
return(coalesce(df[1], df[2]))
}
tag.dat<-tag.dat%>%
group_by(Var1) %>%
summarise_all(coalesce_by_column)
tag.dat<-data.frame(tag.dat[,3:7])
get.first<-function(x){min(which(!is.na(x)))}
f<-apply(tag.dat, 1, get.first)
for(i in 1:nrow(tag.dat)){
for(j in (f[i]+1):ncol(tag.dat)){
tag.dat[i,j]<-ifelse(tag.dat[i,j-1]==0, 0, 1)
}
}
tag.dat<-as.matrix(tag.dat[,1:5])
colnames(tag.dat)<-NULL
tag.dat[is.na(tag.dat)]<-0
tag.dat[6,5]<-1 #new PIT tag added to the individual that is detectable by antenna
tag.dat<-tag.dat[-278,]
# Read in capture history
ms.cap.hist<-read.csv("Sicklefin Capture History.csv")
ms.cap.hist<-ms.cap.hist[-278,]
Sex<-ms.cap.hist$Sex
js.CH<-ms.cap.hist
js.CH$Sex<-NULL
# Convert capture history to data for JS model
js.CH[is.na(js.CH)]<-1 # if NA, assign 1 for "not seen"
CH.du<-as.matrix(cbind(rep(1, dim(js.CH)[1]), js.CH)) # add extra (dummy) sampling occ in the beginning (Kerry and Schaub 2012)
colnames(CH.du)<-NULL
head(CH.du)
nz<-3000 # augmented individuals
ms.js.CH.aug<-rbind(CH.du, matrix(1, ncol=dim(CH.du)[2], nrow=nz)) # data agumentation
tag.dat.aug<-as.matrix(cbind(rep(0,dim(tag.dat)[1]), tag.dat))
tag.dat.aug<-rbind(tag.dat.aug, matrix(0, ncol=dim(tag.dat.aug)[2], nrow=nz))
# Jags data
# Known z values
z.known<-CH.du
n1<-n2<-rep(NA, nrow(CH.du))
for(i in 1:nrow(CH.du)){
n1<-min(which(CH.du[i,]>1))
n2<-max(which(CH.du[i,]>1))
z.known[i,n1:n2]<-2
for(j in 1:ncol(CH.du)){
z.known[i,j]<-ifelse(z.known[i,j]==1, NA, z.known[i,j])
}
}
z.known<-rbind(z.known, matrix(NA, ncol=dim(CH.du)[2], nrow=nz))
# Calculating new and recaps
# get.first<-function(x) min(which(x>1))
# f<-apply(ms.cap.hist, 1, get.first)
# Recap<-NewCap<-rep(NA, 4) # recaps and new caps for 2015-2018
#
# for(n in 1:4){
#   NewCap[n]<-length(f[f==(n+1)]) # number of newly captured individuals 2015-2018
#   Recap[n]<-nrow(ms.cap.hist[!is.na(ms.cap.hist[,n+1])&ms.cap.hist[,n+1]>1&!is.na(ms.cap.hist[,n]),]) # number of recaptured individuals
# }
# Effor data
effort<-read.csv("SRH_Effort_v2.csv", header=T)
#fykeEffort <- tapply(effort$UB_FYKE, effort$Year, sum)
fykeEffort<- c(0, 0, 0, 3, 5, 4) # number of sampling days
##pitEffort <- c(0, 0, 0, 0, 1, 5.25) # ratio of number of sampling days from all antenna in 2017 and 2018, 66 and 347 respectively (Tried to use number of sampling days but model would not run)
#pitEffort <- aggregate(effort[,4:7], by=list(effort$Year), sum)
pitEffort <- c(0, 0, 0, 0, 66, 347)
# Bundle data
dat3<-list(y = ms.js.CH.aug, z=z.known, n.occ = dim(ms.js.CH.aug)[2], Sex=c(Sex, rep(1, nz/2), rep(2, nz/2)), M=dim(ms.js.CH.aug)[1], fykeEffort=fykeEffort, pitEffort=pitEffort, tag.dat.aug=tag.dat.aug)
# Initial values
js.multistate.init <- function(ch, nz){
ch[ch==1] <- NA
state <- ch
for (i in 1:nrow(ch)){
n1 <- min(which(ch[i,]>1))
n2 <- max(which(ch[i,]>1))
state[i,n1:n2] <- 2
}
state[state==0] <- NA
get.first <- function(x) min(which(!is.na(x)))
get.last <- function(x) max(which(!is.na(x)))
f <- apply(state, 1, get.first)
l <- apply(state, 1, get.last)
for (i in 1:nrow(ch)){
state[i,1:f[i]] <- 1
if(l[i]!=ncol(ch)) state[i, (l[i]+1):ncol(ch)] <- 2
state[i, f[i]] <- 2
}
state <- rbind(state, matrix(1, ncol = ncol(ch), nrow = nz))
return(state)
}
z.init<-js.multistate.init(CH.du, nz)
z.init[z.known==2]<-NA
inits <- function() {list(z=cbind(rep(NA, nrow(z.init)),z.init[,-1]), phi= runif(2, 0, 1), gamma=runif(5, 0, 1), p0pit=runif(1, 0, 0.01))}
# Parameters monitored
params <- c("pFyke", "pSeine", "pPit", "phi", "gamma", "Nsuper", "N", "B", "psi")
params <- c("pFyke", "pSeine", "pPit", "phi", "Nsuper", "N", "B", "psi") #"gamma")
nz<-3500 # augmented individuals
ms.js.CH.aug<-rbind(CH.du, matrix(1, ncol=dim(CH.du)[2], nrow=nz)) # data agumentation
tag.dat.aug<-as.matrix(cbind(rep(0,dim(tag.dat)[1]), tag.dat))
tag.dat.aug<-rbind(tag.dat.aug, matrix(0, ncol=dim(tag.dat.aug)[2], nrow=nz))
z.known<-CH.du
n1<-n2<-rep(NA, nrow(CH.du))
for(i in 1:nrow(CH.du)){
n1<-min(which(CH.du[i,]>1))
n2<-max(which(CH.du[i,]>1))
z.known[i,n1:n2]<-2
for(j in 1:ncol(CH.du)){
z.known[i,j]<-ifelse(z.known[i,j]==1, NA, z.known[i,j])
}
}
z.known<-rbind(z.known, matrix(NA, ncol=dim(CH.du)[2], nrow=nz))
effort<-read.csv("SRH_Effort_v2.csv", header=T)
fykeEffort<- c(0, 0, 0, 3, 5, 4) # number of sampling days
pitEffort <- c(0, 0, 0, 0, 66, 347)
dat3<-list(y = ms.js.CH.aug, z=z.known, n.occ = dim(ms.js.CH.aug)[2], Sex=c(Sex, rep(1, nz/2), rep(2, nz/2)), M=dim(ms.js.CH.aug)[1], fykeEffort=fykeEffort, pitEffort=pitEffort, tag.dat.aug=tag.dat.aug)
js.multistate.init <- function(ch, nz){
ch[ch==1] <- NA
state <- ch
for (i in 1:nrow(ch)){
n1 <- min(which(ch[i,]>1))
n2 <- max(which(ch[i,]>1))
state[i,n1:n2] <- 2
}
state[state==0] <- NA
get.first <- function(x) min(which(!is.na(x)))
get.last <- function(x) max(which(!is.na(x)))
f <- apply(state, 1, get.first)
l <- apply(state, 1, get.last)
for (i in 1:nrow(ch)){
state[i,1:f[i]] <- 1
if(l[i]!=ncol(ch)) state[i, (l[i]+1):ncol(ch)] <- 2
state[i, f[i]] <- 2
}
state <- rbind(state, matrix(1, ncol = ncol(ch), nrow = nz))
return(state)
}
z.init<-js.multistate.init(CH.du, nz)
z.init[z.known==2]<-NA
inits <- function() {list(z=cbind(rep(NA, nrow(z.init)),z.init[,-1]), phi= runif(2, 0, 1), gamma=runif(5, 0, 1), p0pit=runif(1, 0, 0.01))}
params <- c("pFyke", "pSeine", "pPit", "phi", "Nsuper", "N", "B", "psi") #"gamma")
ni <- 5000
nt <- 1
nb <- 100
nc <- 3
sr.ms.js.jm2 <- jags.model(data=dat3, inits = inits,
file = "ms_js_phiSex_pGearEffort.jags",
n.chains = nc, n.adapt = nb, quiet = F)
sr.ms.js.jc2 <- coda.samples(sr.ms.js.jm2, params, n.iter=ni)
out.jc2<-summary(sr.ms.js.jc2)
jc2.stats<-out.jc2$statistics # parameter estimates
jc2.quants<-out.jc2$quantiles
plot(sr.ms.js.jc2, ask=TRUE)
pop.size<-data.frame(cbind(Year=c(2014:2018),pop.est=jc1.stats[6:10, 1], lower=jc1.quants[6:10, 1], upper=jc1.quants[6:10, 5]))
pop.size.plot<-ggplot(pop.size, aes(Year, y=pop.est, ymin=lower, ymax=upper))
pop.size.plot+geom_pointrange(size=1) + labs(y="Population Size")+theme(axis.text=element_text(size=20), axis.title=element_text(size=20, face="bold"))+ylim(0,3100)
jc2.stats
jc2.quants
z.known
z.init
ms.cap.hist
Sex
pop.size<-data.frame(cbind(Year=c(2014:2018),pop.est=jc2.stats[6:10, 1], lower=jc2.quants[6:10, 1], upper=jc2.quants[6:10, 5]))
pop.size.plot<-ggplot(pop.size, aes(Year, y=pop.est, ymin=lower, ymax=upper))
pop.size.plot+geom_pointrange(size=1) + labs(y="Population Size")+theme(axis.text=element_text(size=20), axis.title=element_text(size=20, face="bold"))+ylim(0,3100)
plot(sr.ms.js.jc2, ask=TRUE)
jc2.quants
rm(list=ls())
basedirectory <- "C:/Users/solit/Documents/GitHub/Sicklefin-Redhorse-Analysis"
setwd(basedirectory)
list.of.packages <- c("stringr", "reshape2", "RMark","lubridate", "tidyverse", "rjags", "coda")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
lapply(list.of.packages, require, character.only = TRUE)
raw.dat<-read.csv("Sicklefin_Capture_Data.csv")
raw.dat<-raw.dat[raw.dat$Sex!="Unknown",] # remove rows where Sex is "Unknown"
raw.dat$CollectDate<-strptime(raw.dat$CollectDate, format="%d-%b-%y") # convert date format
raw.dat$CollectYear.1<-ifelse(is.na(raw.dat$CollectDate), raw.dat$CollectYear, year(raw.dat$CollectDate))
# Convert tag type
raw.dat$Tag_Type<-ifelse(raw.dat$PIT_Type=="FDX-B",0,1) # if fish was tagged wtih FDX-B, cannot be detected by PIT antenna. If tagged with HDX tag, can be detected by antenna
# Create table with individual and tag detectability over time ("0" for FDX-B tags, "1" for HDX tags)
tag.dat<-data.frame(with(raw.dat, table(raw.dat$Individual_ID, raw.dat$Tag_Type, raw.dat$CollectYear.1)))
tag.dat<-tag.dat[tag.dat$Freq>0,]
tag.dat<-spread(tag.dat, Var3, Var2)
coalesce_by_column <- function(df) {
return(coalesce(df[1], df[2]))
}
tag.dat<-tag.dat%>%
group_by(Var1) %>%
summarise_all(coalesce_by_column)
tag.dat<-data.frame(tag.dat[,3:7])
get.first<-function(x){min(which(!is.na(x)))}
f<-apply(tag.dat, 1, get.first)
for(i in 1:nrow(tag.dat)){
for(j in (f[i]+1):ncol(tag.dat)){
tag.dat[i,j]<-ifelse(tag.dat[i,j-1]==0, 0, 1)
}
}        # create matrix of individual detectability by PIT antenna based on the tag they received
# prepare tag data for model
tag.dat<-as.matrix(tag.dat[,1:5])
colnames(tag.dat)<-NULL
tag.dat[is.na(tag.dat)]<-0
tag.dat[6,5]<-1 #new HDX tag added to this individual in 2018
tag.dat<-tag.dat[-278,] #remove fish that was supposedly captured by seine in Valley River
head(tag.dat)
ms.cap.hist<-read.csv("Sicklefin Capture History.csv")
ms.cap.hist<-ms.cap.hist[-278,] #remove fish that was supposedly captured by seine in Valley River
Sex<-ms.cap.hist$Sex
js.CH<-ms.cap.hist
js.CH$Sex<-NULL
js.CH[is.na(js.CH)]<-1 # if NA, assign 1 for "not seen"
CH.du<-as.matrix(cbind(rep(1, dim(js.CH)[1]), js.CH)) # add extra (dummy) sampling occ in the beginning (Kerry and Schaub 2012)
colnames(CH.du)<-NULL
head(CH.du)
nz<-3500 # augmented individuals
ms.js.CH.aug<-rbind(CH.du, matrix(1, ncol=dim(CH.du)[2], nrow=nz))
tag.dat.aug<-as.matrix(cbind(rep(0,dim(tag.dat)[1]), tag.dat))
tag.dat.aug<-rbind(tag.dat.aug, matrix(0, ncol=dim(tag.dat.aug)[2], nrow=nz))
z.known<-CH.du
n1<-n2<-rep(NA, nrow(CH.du))
for(i in 1:nrow(CH.du)){
n1<-min(which(CH.du[i,]>1))
n2<-max(which(CH.du[i,]>1))
z.known[i,n1:n2]<-2
for(j in 1:ncol(CH.du)){
z.known[i,j]<-ifelse(z.known[i,j]==1, NA, z.known[i,j])
}
}
z.known<-rbind(z.known, matrix(NA, ncol=dim(CH.du)[2], nrow=nz))
effort<-read.csv("SRH_Effort_v2.csv", header=T)
fykeEffort<- c(0, 0, 0, 3, 5, 4) # number of sampling days
pitEffort <- c(0, 0, 0, 0, 66, 347)
dat3<-list(y = ms.js.CH.aug, z=z.known, n.occ = dim(ms.js.CH.aug)[2], Sex=c(Sex, rep(1, nz/2), rep(2, nz/2)), M=dim(ms.js.CH.aug)[1], fykeEffort=fykeEffort, pitEffort=pitEffort, tag.dat.aug=tag.dat.aug)
js.multistate.init <- function(ch, nz){
ch[ch==1] <- NA
state <- ch
for (i in 1:nrow(ch)){
n1 <- min(which(ch[i,]>1))
n2 <- max(which(ch[i,]>1))
state[i,n1:n2] <- 2
}
state[state==0] <- NA
get.first <- function(x) min(which(!is.na(x)))
get.last <- function(x) max(which(!is.na(x)))
f <- apply(state, 1, get.first)
l <- apply(state, 1, get.last)
for (i in 1:nrow(ch)){
state[i,1:f[i]] <- 1
if(l[i]!=ncol(ch)) state[i, (l[i]+1):ncol(ch)] <- 2
state[i, f[i]] <- 2
}
state <- rbind(state, matrix(1, ncol = ncol(ch), nrow = nz))
return(state)
}
z.init<-js.multistate.init(CH.du, nz)
z.init[z.known==2]<-NA
inits <- function() {list(z=cbind(rep(NA, nrow(z.init)),z.init[,-1]), phi= runif(2, 0, 1), gamma=runif(5, 0, 1), p0pit=runif(1, 0, 0.01))}
params <- c("pFyke", "pSeine", "pPit", "phi", "Nsuper", "N", "B", "psi") #"gamma")
ni <- 50000
nt <- 1
nb <- 100
nc <- 3
out.jc1
out.jc1<-summary(sr.ms.js.jc1) # model output
load("SRH_JS_phiSex_pGearEffort_100000.gzip")
out.jc1<-summary(sr.ms.js.jc1) # model output
jc1.stats<-out.jc1$statistics # parameter estimates
jc1.quants<-out.jc1$quantiles # 95% confidence intervals
plot(sr.ms.js.jc2, ask=TRUE)
plot(sr.ms.js.jc1, ask=TRUE)
nrow(ms.js.CH.aug)
nrow(tag.dat.aug)
nrow(Sex)
